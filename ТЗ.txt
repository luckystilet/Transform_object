Ми маємо масив n об&#39;єктів однакової структури. Сама структура об&#39;єкта невідома (типи полів, їх рівень
вкладення). Поля в об&#39;єкті можуть бути іншими складними об&#39;єктами, типом Date, string, number, boolean.
Є об&#39;єкт такої самої структури, але з типами полів boolean. Використовується для задання правил
перетворень (якщо значення поля true - то поле має бути в результуючому масиві). Також є об&#39;єкт з типами
полів string, в яких зберігаються локалізовані заголовки полів. Назви полів, в яких зберігаються локалізовані
заголовки, відповідають шляху до поля в об&#39;єкті, в якому зберігається його значення.
Необхідно написати код, який на основі вищеописаних об&#39;єктів створить масив об&#39;єктів наступної структури: 
{
name : &#39;заголовок поля&#39;,
value1 : &#39;значення поля в об&#39;єкті №1&#39;,
value2 : &#39;значення поля в об&#39;єкті №2&#39;,
...
value[n-1] : &#39;значення поля в об&#39;єкті №[n-1]&#39;,
value[n] : &#39;значення поля в об&#39;єкті №[n]&#39;
}
Якщо поле типу boolean - то виводити його значення у вигляді Так/Ні, дату виводити в форматі dd.MM.yyyy
Передбачити варіант, що для поля може бути відсутня локалізація. В такому випадку замість локалізації
необхідно вивести назву цього поля.
Приклад:
[{fullName : {surname : &#39;xxx&#39;, firstName : &#39;yyy&#39;, middleName: &#39;zzz&#39;}}, {fullName : {surname : &#39;XXX&#39;, firstName : &#39;YYY&#39;,
middleName: &#39;ZZZ&#39;}}] - масив об&#39;єктів
{fullName : {surname : true, firstName : true, middleName: false}} - правило перетворень
{&quot;fullName.surname&quot; : &quot;Прізвище&quot;, &quot;fullName.middleName&quot; : &quot;По-батькові&quot;} - локалізації
[{name : &quot;Прізвище&quot;, value1 : &quot;xxx&quot;, value2 : &quot;XXX&quot;}, {name : &quot;firstName&quot;, value1 : &quot;yyy&quot;, value2 : &quot;YYY&quot;}] -
результат